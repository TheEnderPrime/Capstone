\documentclass[letterpaper,10pt,draftclsnofoot,onecolumn,titlepage]{IEEEtran}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}


\def\name{Sawyer Kokesh, Nathen Burnett, Bradley Huffman}

%pull in the necessary preamble matter for pygments output
%\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
	colorlinks = true,
	urlcolor = black,
	pdfauthor = {\name},
	pdfkeywords = {cs444 ``operating systems 2'' writing assignment 1},
	pdftitle = {Writing Topic 1: Processes},
	pdfsubject = {CS 444 Processes},
	pdfpagemode = UseNone
}
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
	\title{CS444 Writing Topic 1: Processes}
	\author{Sawyer~Kokesh}
	\maketitle
Windows scheduling compares threads and determines which thread receives the next processor time slice when multitasking. The determination of the thread that runs next is compared using scheduling priorities. The scheduling priorities are set from zero to thirty one. The windows scheduler treats all threads with the same priority equally, it does this by a round-robin fashion. The round-robin only uses the highest priority threads. If none of the threads are ready to run then the system assigns the next higher-priority thread. The interesting thing about the scheduler is if a higher priority thread comes along, the lower priority thread stops immediately and a whole time slice is given to the higher priority thread. Windows Processes provides the needed resources to execute a program. The processes are created from a single thread called a primary thread and every processes needs one. From this primary thread the processes can create many more threads. The thread is an entity inside the processes that can be scheduled for execution. Processes share a virtual address space and system resources with all of that processes threads. Each thread contains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and structure to save the thread context until it is scheduled.Windows also supports preemptive multitasking, in other words it creates a effect of execution of many threads from at the same time from multiple processes. For a computer with a multiprocessor the system actually can simultaneously execute the number of threads as the number of processors on the computer. Another thing that windows is allowing is a job object which gives the ability to group processes and be managed by a unit. Theses objects are nameable, securable,sharable. Which allows operations to be performed to all processes associated with a job object. In windows you are also give a user mode scheduling tool which allows for an application to use schedules on their own threads. So in a why there is a why to have your own application to schedule its own internal time usage for the usage that is given to by the cpu.

Linux is set up as a vector of structs, the vector is a list of tasks. Each element in the vector is a pointer to a task struct. The task struct is a system representation of a process for linux. Because of this there is a maximum number of processes in a system. To make it easy to find the current process there is a current process pointer that points to the current process in the task vector. Linux with its normal user processes contains also a real time processes. These real time processes are processes that have to react to external events very quickly and these processes are treated differently by the scheduler. In terms of the scheduler all of the processes run in both in user mode and system mode. There is always a secure mechanism from getting from the user mode to the system mode and back again. There are some differences between the user and system modes. The user mode has far less privileges than the system mode. Therefore the system mode is able to do more but should be better protected. The scheduler is in charge of choosing which process is most deserving process. Linux uses a simple idea to run the scheduler, when the time is up for a process then all of the information is saved in the task struct and then the control of the cpu is given to the next process, and so on and so forth. When the scheduler gives back the cpu to a process then the previous information is already stored and can continue right away. There is a priority of each of the processes, the priority is not like that of windows. In linux the priority relates to the amount of time that the process is allocated, but in windows priority is like levels of an apartment building, you can't go help the lower level floors tell you help the top floors, and if someone on the top floor needs help, they get it before anyone else. But both linux and windows are round robin, as in each one takes control of the cpu then passes on, and if it does not finish it gets put on the stack.

FreeBSD is considered a multitasking operating system, as in each program that is running at any given time is called a process. For each one of theses process there are a bunch of system processes that have to run as well. Process have a few things, it has a id, owner, group, and permissions. Like all of the schedulers so far this one is no different in the main goal. Which is to fairly give out the time of the cpu to processes. The processes are scheduled in what is called a completely fair scheduler, which means that it is not based on run queues for process selection. Instead it uses a red-black tree. In other words it runs on a self-balancing binary search tree. This is far from linux and windows scheduler because of the fact they both use a queue or stack to order the priority of these processes. When the process for FreeBSD is created it is given a lot of cpu time because if it a sort process the system will be able to finish it right fast. This is also consider a real-time scheduler because it does not do deadline scheduling. What this does share with windows and linux is they all can do round robin scheduling. They all can use a method of using context switching to cycle through current processes, and provide them with a about of time for them to run their process. So in all of these, they both different and similar but they try to accomplish the same thing. A fast a fair and a efficient way to both handle processes and threads, to allows them to run with the cpu.

	%input the pygmentized output of mt19937ar.c, using a (hopefully) unique name
	%this file only exists at compile time. Feel free to change that.
	%\input{__mt19937ar.h.tex}
	\nocite{*}
	\bibliography{references.bib}
	\bibliographystyle{plain}
\end{document}